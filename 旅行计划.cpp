//有n个城市，给出邻接矩阵arr代表任意两个城市的距离。
// arr[i][j]代表从城市i到城市j的距离。Alice在周末制定了一个游玩计划，
// 她从所在的0号城市开始，游玩其他的1 ~n - 1个城市，最后回到0号。
// Alice想知道她能完成游玩计划需要行走的最小距离。返回这个最小距离。
// 除了城市0之外每个城市都只能经过一次，且城市0只能是起点和终点，
// Alice中途不可经过城市0。
//
//n <= 10
//arr[i][j] <= 10000
//
//样例
//例1 :
//
//输入:
//[[0, 1, 2], [1, 0, 2], [2, 1, 0]]
//输出 :
//	4
//	解释 :
//      0  1  2
//	0 [[0, 1, 2],
//	1  [1, 0, 2],
//	2  [2, 1, 0]]
//有两种可能的方案。a[0][1] [1][2] [2][0]
//第一种，城市0->城市1->城市2->城市0，cost = 5。
//第二种，城市0->城市2->城市1->城市0，cost = 4。
//返回4   a[0][2]  [2][1] [1][0]
//例2 :
//
//输入:
//[[0, 10000, 2], [5, 0, 10000], [10000, 4, 0]]
//输出 :
//	11


#include<stdio.h>
#define row 3
#define col 3

int main()
{
	
	
	int i = 0, j = 0;
	int arr[row][col] = { 0 };
	int cost = 0;
	for (i = 0; i < row; i++)
	{
		for (j = 0; j < col; j++)
		{
			scanf("%d", &arr[i][j]);
		}
	}
	int cost1 = arr[0][1] + arr[1][2] + arr[2][0];
	int cost2 = arr[0][2] + arr[2][1] + arr[1][0];
	if (cost1 > cost2)
		cost = cost2;
	else
		cost = cost1;

	printf("%d\n", cost);
	return 0;
}